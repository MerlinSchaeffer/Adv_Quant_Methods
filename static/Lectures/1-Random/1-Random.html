<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>1 Randomness!</title>
    <meta charset="utf-8" />
    <meta name="author" content="Merlin Schaeffer  Department of Sociology" />
    <meta name="date" content="2022-05-21" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/tile-view/tile-view.css" rel="stylesheet" />
    <script src="libs/tile-view/tile-view.js"></script>
    <link href="libs/tachyons/tachyons.min.css" rel="stylesheet" />
    <link href="libs/panelset/panelset.css" rel="stylesheet" />
    <script src="libs/panelset/panelset.js"></script>
    <link rel="stylesheet" href="libs/Merlin169.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# 1 Randomness!
## &amp; its increadible importance for social science research
### Merlin Schaeffer<br> Department of Sociology
### 2022-05-21

---


# The goal of social science research

.font140[.center[.alert[Use data to discover patterns ("social facts" in Durkheim's terms), &lt;br&gt; and the social mechanisms that bring them about.]]]

&lt;img src="https://liu.se/-/media/istock-501261958.jpg?mw=1120&amp;mh=1120&amp;hash=DA8977CCE6A6E600AE80A40CFEE771C9" width="70%" style="display: block; margin: auto;" /&gt;

---
# Why randomness?

.push-left[.content-box-red[
.center[**We rely on randomness to&lt;br&gt; draw unbiased conclusions from data**]

- *Specifically*, two types of conclusions:
  1. Random sample `\(\rightarrow\)` general population.
  2. Random `\(x \rightarrow\)` causal effect of `\(x\)` on `\(y\)`.


- More *fundamentally*:
  + Which social mechanisms generate the population and its patterns? &lt;br&gt; (aka the 'Data Generating Process')
]]





.push-right[
&lt;img src="https://m.media-amazon.com/images/I/71jm22A7m9L._AC_SL1200_.jpg" width="80%" style="display: block; margin: auto;" /&gt;
.center[.backgrnote[
Similar to some mirrors that give us a biased reflection,&lt;br&gt; many data sources we use to draw insights about how societies work also lead to biased insights.]]
]

---
class: inverse middle center

.push-left[
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
Excuse me?!

**How can randomness lead to unbiased insights about the fundamental ways in which society works?**
]

.push-right[
&lt;img src="https://www.wearekura.com/wp-content/uploads/2017/08/identity-struggle.jpg" width="60%" style="display: block; margin: auto;" /&gt;
]

---
# Think about it

.push-left[
.content-box-green[
Why do many games have a random element?
]

&lt;img src="https://upload.wikimedia.org/wikipedia/commons/7/78/Monopoly_board_on_white_bg.jpg" width="60%" style="display: block; margin: auto;" /&gt;
]

--

.push-right[
&lt;img src="https://lotterylab.s3.amazonaws.com/summernoteimages/606ffa6b3468c.gif" width="80%" style="display: block; margin: auto;" /&gt;

1. Thrill: No one knows the outcome.

2. .font120[.alert[Fairness!]] Known and similar probabilities for everyone, *regardless of who they are*.

]

---
# Samples

.center[**Research is based on samples for one of two reasons:**]

--

.push-left[
1) Populations are too large to study everyone.

&lt;img src="https://www.kuechengoetter.de/uploads/media/630x630/02/28602-suppentopf-mit-nudeln-und-haehnchen.jpg?v=1-0" width="50%" style="display: block; margin: auto;" /&gt;
.center[.backgrnote[
Our sample is basically a tasting of what's cooking &lt;br&gt;(i.e., what's really going on).]]

]

--

.push-right[
2) Even if we have (e.g., register) data on everyone, .font120[.alert[we are interested in social mechanisms]].
For example, we *generally* want to know, whether:
  - Urbanization results in a blas√© outlook (Simmel).
  - Anomie makes people suicidal (Durkheim).
  - Capitalism alienates people from their creative talents (Marx).
    
    
  `\(\rightarrow\)` We generally want to know these things, not only for the current population of Denmark. We thus treat any data as a sample of an unobservable "super population".
]

--

.left-column[

]

---
# Convenience samples

.left-column[
Samples should be representative: They should accurately reflect the (unobservable super) population.

.content-box-green[
If you sampled among your friends and family, what biases would that result in? That is, who would be underrepresented?
]
]

.right-column[
&lt;img src="img/Convenience_Sample.png" width="100%" style="display: block; margin: auto;" /&gt;
]

---
# Random samples!

.push-left[

&lt;img src="https://lotterylab.s3.amazonaws.com/summernoteimages/606ffa6b3468c.gif" width="60%" style="display: block; margin: auto;" /&gt;

&lt;br&gt;
&lt;br&gt;
Random samples are "fair": Everyone in the (unobservable super) population has the same probability to be part of the sample, .alert[regardless of who they are]!

`\(\rightarrow\)` No group can be forgotten.
]

--

.push-right[
&lt;br&gt;
&lt;br&gt;
&lt;img src="https://www.kuechengoetter.de/uploads/media/630x630/02/28602-suppentopf-mit-nudeln-und-haehnchen.jpg?v=1-0" width="50%" style="display: block; margin: auto;" /&gt;
.center[.backgrnote[
Random sampling is basically the equivalent of giving the soup a proper stir before we taste it ;).]]
]

---
class: inverse middle center

.push-right[
&lt;br&gt;
Nice talk man.

**But we all know that it's not random who participates in a study**

&lt;br&gt;
&lt;img src="https://bloximages.chicago2.vip.townnews.com/buffalonews.com/content/tncms/assets/v3/editorial/1/dc/1dc9a2da-fc52-11eb-9244-2b611ea83ea0/61169b5e36ff5.image.jpg" width="70%" style="display: block; margin: auto;" /&gt;

]

.push-left[
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;img src="https://www.business2community.com/wp-content/uploads/2013/03/Question1.jpg" width="60%" style="display: block; margin: auto;" /&gt;
]

---
# Weights

.push-left[
- A *weight* tells you the probability that an observation should be in the sample. For a true random sample, each case of the population has an equal probability to be sampled. Thus the weight would be 1 for every observation of a sample.
-  Yet, for various reasons, some populations tend to be under-sampled. Post-stratification weights try to counterbalance this.
&lt;br&gt;

.content-box-green[.center[
Why would survey researchers assign lower weights to older people?
]]]

.push-right[
.panelset[
.panel[.panel-name[Plot]


```
# Error in `select()`:
# ! Can't subset columns that don't exist.
# x Column `id` doesn't exist.
```

&lt;img src="1-Random_files/figure-html/weights_fig-1.png" width="100%" style="display: block; margin: auto;" /&gt;
]
.panel[.panel-name[Code]

```r
library(tidyverse) # Data manipulation.
library(haven) #&lt;&lt; Handle labelled data.
library(essurvey) # Read ESS data from API.

# Import the ESS round 9 data via the API
ESS &lt;- import_country(
  country = "Denmark", rounds = 9,
  ess_email = YOUR_EMAIL, format = "spss") %&gt;%
  # Keep only a minimum set of variables I need today
  select(id, pspwght, agea, eduyrs, agea) %&gt;%
  drop_na() # Delete cases with missing values
# Error in `select()`:
# ! Can't subset columns that don't exist.
# x Column `id` doesn't exist.
ggplot(data = ESS, 
       mapping = aes(y = pspwght, x = agea)) +
  geom_point(alpha = 0.3) +
  geom_smooth(method = "lm", SE = FALSE) + # OLS regression line.
  labs(y = "Post-stratification weight", x = "Age in years",
       caption = "Danish European Social Survey 2018") +
  theme_minimal()
```
]]]

---
# Working with weights

- Statistically, we use weights by multiplication. 

.push-left[
- Imagine a patriarchal society, where men's votes count twice as much. Here we have a ballot on whether women should be allowed to drive:

&lt;table&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:right;"&gt; i &lt;/th&gt;
   &lt;th style="text-align:left;"&gt; Gender &lt;/th&gt;
   &lt;th style="text-align:left;"&gt; Vote &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; Voted yes &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; Weight &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; man &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; No &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 2 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 2 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; man &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; Yes &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 2 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 3 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; woman &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; Yes &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 4 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; woman &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; Yes &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 5 &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; woman &lt;/td&gt;
   &lt;td style="text-align:left;"&gt; No &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

.center[
.content-box-green[
What is the patriarchy-weighted percent &lt;br&gt; of "Yes"-votes?
]
]
]

--

.push-right[
- Three equivalent ways to the percent of patriarchy-weighted "Yes"-votes:

.panelset[
.panel[.panel-name[1.]

```r
((0*2 + 1*2 + 1 + 1 + 0) / 7) * 100 # 1
# [1] 57.1
```
]
.panel[.panel-name[2.]

```r
(sum(`Voted yes` * weight) / sum(weight)) * 100 # 2
# Error in eval(expr, envir, enclos): object 'weight' not found
```
]
.panel[.panel-name[3.]

```r
weighted.mean(x = `Voted yes`, w = weight) * 100 # 3
# Error in weighted.mean.default(x = `Voted yes`, w = weight): object 'weight' not found
```
]]]

---
# Weights really work!

.push-left[
&lt;img src="img/Wang1.png" width="100%" style="display: block; margin: auto;" /&gt;
]

--

.push-right[
&lt;img src="img/Wang2.png" width="100%" style="display: block; margin: auto;" /&gt;
]


---
# Working with weights

.left-column[
- Most R commands have a weights argument.

- With OLS regression you should use: `estmiatr::lm_robust()`. 
.backgrnote[
Using weights results in heteroscedastic residuals, which violates an assumption of OLS. lm_robust() corrects for that (i.e., is robust to it).]
]

.right-column[
.panelset[


.panel[.panel-name[Example]
&lt;img src="1-Random_files/figure-html/ols_fig-1.png" width="90%" style="display: block; margin: auto;" /&gt;
]
.panel[.panel-name[OLS Regression]
&lt;table class="texreg" style="margin: 10px auto;border-collapse: collapse;border-spacing: 0px;caption-side: bottom;color: #000000;border-top: 2px solid #000000;"&gt;
&lt;caption&gt;Statistical models&lt;/caption&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style="padding-left: 5px;padding-right: 5px;"&gt;&amp;nbsp;&lt;/th&gt;
&lt;th style="padding-left: 5px;padding-right: 5px;"&gt;Unweighted&lt;/th&gt;
&lt;th style="padding-left: 5px;padding-right: 5px;"&gt;Weighted&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr style="border-top: 1px solid #000000;"&gt;
&lt;td style="padding-left: 5px;padding-right: 5px;"&gt;(Intercept)&lt;/td&gt;
&lt;td style="padding-left: 5px;padding-right: 5px;"&gt;2.204&lt;sup&gt;***&lt;/sup&gt;&lt;/td&gt;
&lt;td style="padding-left: 5px;padding-right: 5px;"&gt;2.377&lt;sup&gt;***&lt;/sup&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="padding-left: 5px;padding-right: 5px;"&gt;&amp;nbsp;&lt;/td&gt;
&lt;td style="padding-left: 5px;padding-right: 5px;"&gt;(0.091)&lt;/td&gt;
&lt;td style="padding-left: 5px;padding-right: 5px;"&gt;(0.113)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="padding-left: 5px;padding-right: 5px;"&gt;eduyrs&lt;/td&gt;
&lt;td style="padding-left: 5px;padding-right: 5px;"&gt;0.039&lt;sup&gt;***&lt;/sup&gt;&lt;/td&gt;
&lt;td style="padding-left: 5px;padding-right: 5px;"&gt;0.024&lt;sup&gt;**&lt;/sup&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="padding-left: 5px;padding-right: 5px;"&gt;&amp;nbsp;&lt;/td&gt;
&lt;td style="padding-left: 5px;padding-right: 5px;"&gt;(0.006)&lt;/td&gt;
&lt;td style="padding-left: 5px;padding-right: 5px;"&gt;(0.008)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style="border-top: 1px solid #000000;"&gt;
&lt;td style="padding-left: 5px;padding-right: 5px;"&gt;R&lt;sup&gt;2&lt;/sup&gt;&lt;/td&gt;
&lt;td style="padding-left: 5px;padding-right: 5px;"&gt;0.025&lt;/td&gt;
&lt;td style="padding-left: 5px;padding-right: 5px;"&gt;0.010&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="padding-left: 5px;padding-right: 5px;"&gt;Adj. R&lt;sup&gt;2&lt;/sup&gt;&lt;/td&gt;
&lt;td style="padding-left: 5px;padding-right: 5px;"&gt;0.024&lt;/td&gt;
&lt;td style="padding-left: 5px;padding-right: 5px;"&gt;0.009&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style="padding-left: 5px;padding-right: 5px;"&gt;Num. obs.&lt;/td&gt;
&lt;td style="padding-left: 5px;padding-right: 5px;"&gt;1520&lt;/td&gt;
&lt;td style="padding-left: 5px;padding-right: 5px;"&gt;1520&lt;/td&gt;
&lt;/tr&gt;
&lt;tr style="border-bottom: 2px solid #000000;"&gt;
&lt;td style="padding-left: 5px;padding-right: 5px;"&gt;RMSE&lt;/td&gt;
&lt;td style="padding-left: 5px;padding-right: 5px;"&gt;&amp;nbsp;&lt;/td&gt;
&lt;td style="padding-left: 5px;padding-right: 5px;"&gt;0.890&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;tfoot&gt;
&lt;tr&gt;
&lt;td style="font-size: 0.8em;" colspan="3"&gt;&lt;sup&gt;***&lt;/sup&gt;p &amp;lt; 0.001; &lt;sup&gt;**&lt;/sup&gt;p &amp;lt; 0.01; &lt;sup&gt;*&lt;/sup&gt;p &amp;lt; 0.05&lt;/td&gt;
&lt;/tr&gt;
&lt;/tfoot&gt;
&lt;/table&gt;
]
.panel[.panel-name[Code]

```r
library(estimatr) # Weighted OLS regression with robust inference.
library(texreg) # Nicely-formatted regression tables.

# Prepare the data
ESS &lt;- ESS %&gt;% mutate(
    psppsgva = zap_labels(psppsgva), # Make numeric
    eduyrs = case_when( # Censor years of education at 9 &amp; 21 years.
        eduyrs &gt; 21 ~ 21,
        eduyrs &lt; 9 ~ 9,
        TRUE ~ as.numeric(eduyrs)),
    gndr = as_factor(gndr)) # Make factor

# Estimate the models
mod1 &lt;- lm(psppsgva ~ eduyrs, # Unweighted
           data = ESS)
mod2 &lt;- lm_robust(psppsgva ~ eduyrs, # Weighted
                  weights = pspwght, 
                  data = ESS)

# Make a nice table
htmlreg(list(mod1, mod2), 
        include.ci = FALSE, digits = 3,
        custom.model.names = c("Unweighted", "Weighted"))
```
]]]

---
class: inverse middle center

.push-left[
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;img src="https://www.business2community.com/wp-content/uploads/2013/03/Question1.jpg" width="60%" style="display: block; margin: auto;" /&gt;
]

.push-left[
&lt;br&gt;
OK, great: Randomness prohibits systematic biases and thus enables us to draw unbiased representative samples. If randomization has partly failed, we use post-stratification weights to counterbalance.

**But doesn't all this mean that I have randomness (e.g., just by chance too many vegetarians or so) and thus also bias in my data?**
]

---
# Sampling error `\(\sigma\)` .font60[(aka sampling variability)]

.push-left[
- **Lets assume, the Danish ESS with it's 1572 respondents was our (unobservable super) population of interest.** 
  + Thus, I don't use weights in this example ;)


- That would mean, we know the true OLS regression line (in blue): `\(\beta = 0.039\)`
]

.push-right[
&lt;img src="1-Random_files/figure-html/true_ols-1.png" width="90%" style="display: block; margin: auto;" /&gt;
]

---
# Sampling error `\(\sigma\)` .font60[(aka sampling variability)]

.push-left[
- **Lets assume, the Danish ESS with it's 1572 respondents was our (unobservable super) population of interest.** 
  + Thus, I don't use weights in this example ;)


- That would mean, we know the true OLS regression line (in blue): `\(\beta = 0.039\)`

- Now I take a random sample of 50 persons.


```r
set.seed(831983) # Random seed, to reproduce result.
ESS_sample &lt;- ESS %&gt;% sample_n(50) # Draw the sample.
```
]

.push-right[
&lt;img src="1-Random_files/figure-html/sample1_ols1-1.png" width="90%" style="display: block; margin: auto;" /&gt;
]

---
# Sampling error `\(\sigma\)` .font60[(aka sampling variability)]

.push-left[
- **Lets assume, the Danish ESS with it's 1572 respondents was our (unobservable super) population of interest.** 
  + Thus, I don't use weights in this example ;)


- That would mean, we know and can *calculate* the true OLS regression line (in blue): `\(\beta = 0.039\)`

- Now I take a random sample of 50 persons.


```r
set.seed(831983) # Random seed, to reproduce result.
ESS_sample &lt;- ESS %&gt;% sample_n(50) # Draw the sample.
```

- ... and *estimate* an OLS regression line based on that 50-person sample (in red): `\(\hat{\beta} = 0.087\)`
]

.push-right[
&lt;img src="1-Random_files/figure-html/sample1_ols2-1.png" width="90%" style="display: block; margin: auto;" /&gt;
]

---
# Sampling error `\(\sigma\)` .font60[(aka sampling variability)]

.push-left[
- **Lets assume, the Danish ESS with it's 1572 respondents was our (unobservable super) population of interest.** 
  + Thus, I don't use weights in this example ;)


- That would mean, we know and can *calculate* the true OLS regression line (in blue): `\(\beta = 0.039\)`

- .alert[Let's take another random sample of 50 persons.]


```r
ESS_sample_2 &lt;- ESS %&gt;% sample_n(50) # Draw the sample.
```

- ... and *estimate* an OLS regression line based on that 50-person sample (in red): `\(\hat{\beta} = 0.069\)`
]

.push-right[
&lt;img src="1-Random_files/figure-html/sample1_ols3-1.png" width="90%" style="display: block; margin: auto;" /&gt;
]

---
# Let's do this a 1000 times more!

.panelset[
.panel[.panel-name[Code for the Nerds]

```r
Samples &lt;- bind_rows(ESS_sample, ESS_sample_2, 
                     .id = "sample_nr") %&gt;%
  mutate(sample_nr = as.numeric(sample_nr))

for (draw in 3:103) {
  Samples &lt;- bind_rows(
    Samples,
    ESS %&gt;% sample_n(50) %&gt;% mutate(sample_nr = draw))
}
```
]
.panel[.panel-name[Animated figure]

```r
library(gganimate)

ggplot(data = Samples, aes(y = psppsgva, x = eduyrs)) +
  geom_point(alpha = 0.5, color = "#901A1E") +
  geom_smooth(method = "lm", se = FALSE, color = "#901A1E", size = 0.7) +
  geom_smooth(data = ESS, method = "lm", se = FALSE) +
  theme_minimal() +
  labs(y = "The political system allows people \n to have a say in what government does",
       x = "Years of education") +
  transition_states(factor(sample_nr),
                    transition_length = 100,
                    state_length = 500) +
  shadow_mark(alpha = 0.1, size = 0.1)
```

&lt;img src="1-Random_files/figure-html/unnamed-chunk-25-1.gif" style="display: block; margin: auto;" /&gt;
]]

---



---
class: inverse middle center

.push-left[
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
&lt;img src="https://www.business2community.com/wp-content/uploads/2013/03/Question1.jpg" width="60%" style="display: block; margin: auto;" /&gt;
]

.push-left[
&lt;br&gt;
Duh! But if I can't sample the whole (unobservable super) population, then I surely also can't draw thousands of 50 person samples or so.

**So is there no applied solution to the sampling error problem?**
]

---
# The standard error `\(\hat{\sigma}\)` .font70[(i.e., estimated sampling error)]

.push-left[
**Goal**: Gain unbiased insights from data.

.center[
`\(\downarrow\)` 
]

**Solution**: *Random sampling* prohibits systematic biases, and *weighting* helps to alleviate partly failed randomization.

.center[
`\(\downarrow\)` 
]

**Problem**: Random samples contain unsystematic *sampling error*.

.center[
`\(\downarrow\)` 
]

**Question**: With how much confidence can we *infer* (i.e., generalize) from our random sample?
]

--

.push-right[
.push-left[
&lt;img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/ec/Carl_Friedrich_Gauss_1840_by_Jensen.jpg/440px-Carl_Friedrich_Gauss_1840_by_Jensen.jpg" width="60%" style="display: block; margin: auto;" /&gt;
.center[.backgrnote[Carl Friedrich Gauss (1777-1855)]]
]
.push-right[
Thanks to mathematicians, such as Carl Friedrich Gauss, we can *estimate* the sampling error of most statistics based on a single sample!
]]

---
# The standard error of OLS `\(\hat{\sigma}(\beta)\)`

.push-left[
True sampling error from our repeated samples:
]

.push-right[
Estimated sampling errors each based on a single sample using Gauss' formula for the standard error of an OLS regression coefficient: `\(\hat{\sigma}(\beta)=\sqrt{\frac{1}{n-2}\frac{\text{SD}(e)}{\text{SD}(x)}}\)`.



]



---
class: inverse
# Today's general lessons


---
class: inverse
# Today's (important) R functions

---
# References
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="libs/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightLanguage": "r",
"highlightStyle": "zenburn",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
